// Code generated by protoc-gen-go-http-server.
// source: pb/strings.proto

package strings

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/doroginin/protobuf/protoc-gen-go-http-server/types"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
)

func init() {
	defaultStringsHTTPServerOptions.cdc = &StringsCodec{}
}

type StringsCodec struct {
}

func (c *StringsCodec) ReadRequest(req *http.Request) (*http.Request, string, interface{}, error) {
	if data, ok := _StringsFromContext(req.Context()); ok {
		return req, data.method, data.request, nil
	}
	components := strings.Split(strings.Trim(req.URL.Path, "/"), "/")
	l := len(components)
	var verb string

	if idx := strings.LastIndex(components[l-1], ":"); idx == 0 {
		return req, "", nil, types.ErrMethodNotFound
	} else if idx > 0 {
		c := components[l-1]
		components[l-1], verb = c[:idx], c[idx+1:]
	}
	if dataMap, err := pattern_Strings_ToUpper_0.Match(components, verb); err == nil {
		if req.Method != "GET" {
			return req, "", nil, types.ErrMethodNotFound
		}
		data := &StringRequest{}
		for k, v := range dataMap {
			runtime.PopulateFieldFromPath(data, k, v)
		}
		return req.WithContext(_StringsNewContext(req.Context(), &_StringsCodecData{
			method:  "ToUpper",
			request: data,
		})), "ToUpper", data, nil
	}

	if idx := strings.LastIndex(components[l-1], ":"); idx == 0 {
		return req, "", nil, types.ErrMethodNotFound
	} else if idx > 0 {
		c := components[l-1]
		components[l-1], verb = c[:idx], c[idx+1:]
	}
	if dataMap, err := pattern_Strings_ToUpper_1.Match(components, verb); err == nil {
		if req.Method != "GET" {
			return req, "", nil, types.ErrMethodNotFound
		}
		data := &StringRequest{}
		for k, v := range dataMap {
			runtime.PopulateFieldFromPath(data, k, v)
		}
		return req.WithContext(_StringsNewContext(req.Context(), &_StringsCodecData{
			method:  "ToUpper",
			request: data,
		})), "ToUpper", data, nil
	}

	if len(components) == 2 && components[0] == "Strings" && components[1] == "ToLower" {
		if req.Method != "POST" {
			return req, "", nil, types.ErrMethodNotFound
		}
		data := &StringRequest{}
		decoder := json.NewDecoder(req.Body)
		err := decoder.Decode(data)
		req.Body.Close()
		if err == nil {
			return req.WithContext(_StringsNewContext(req.Context(), &_StringsCodecData{
				method:  "ToLower",
				request: data,
			})), "ToLower", data, nil
		}
		return req, "", nil, fmt.Errorf("Could not decode request: %s, ", err)
	}

	return req, "", nil, types.ErrMethodNotFound
}

func (c *StringsCodec) WriteResponse(w http.ResponseWriter, resp interface{}, err error) error {
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		bResp, _ := json.Marshal(&defaultError{Error: err.Error()})
		_, err = w.Write(bResp)
		return err
	}
	bResp, err := json.Marshal(resp)
	if err != nil {
		return err
	}
	_, err = w.Write(bResp)
	return err
}

type _StringsCodecData struct {
	method  string
	request interface{}
}

type _StringsCtxKeyType int

var _StringsCtxKey _StringsCtxKeyType

func _StringsNewContext(ctx context.Context, d *_StringsCodecData) context.Context {
	return context.WithValue(ctx, _StringsCtxKey, d)
}

func _StringsFromContext(ctx context.Context) (*_StringsCodecData, bool) {
	data := ctx.Value(_StringsCtxKey)
	if data == nil {
		return nil, false
	}
	d, ok := data.(*_StringsCodecData)
	return d, ok
}

type defaultError struct {
	Error string `json:"error"`
}

var (
	pattern_Strings_ToUpper_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2}, []string{"strings", "to_upper", "str"}, ""))

	pattern_Strings_ToUpper_1 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"v1", "strings", "to_upper", "str"}, ""))
)
