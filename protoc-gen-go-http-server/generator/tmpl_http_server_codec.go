package generator

import (
	"strings"
	"text/template"
)

var CodecTemplate = &Template{
	FileName: "%s.pb.http.server.codec.go",
	Body: template.Must(template.New(`file`).Funcs(template.FuncMap{
		`ToLower`: strings.ToLower,
	}).Parse(`
// Code generated by protoc-gen-go-http-server.
// source: {{ .Source }}

package {{ .Package }}

import (
	"fmt"
	"context"
	"strings"
	"net/http"
	"encoding/json"

	"github.com/doroginin/protobuf/protoc-gen-go-http-server/types"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
)

func init() { {{ range $si, $service := .Services }}
	default{{ $service.Name }}HTTPServerOptions.cdc = &{{ $service.Name }}Codec{}
{{ end }} }

{{ range $si, $service := .Services }}
type {{ $service.Name }}Codec struct{
}

func (c *{{ $service.Name }}Codec) ReadRequest(req *http.Request) (*http.Request, string, interface{}, error) {
	if data, ok := _{{ $service.Name }}FromContext(req.Context()); ok {
		return req, data.method, data.request, nil
	}
	components := strings.Split(strings.Trim(req.URL.Path, "/"), "/")
	l := len(components)
	var verb string
	{{ range $hi, $handler := $service.Handlers }}
		{{ if $handler.Bindings }}
   			{{ range $bId, $binding := $handler.Bindings }}
				if idx := strings.LastIndex(components[l-1], ":"); idx == 0 {
					return req, "", nil, types.ErrMethodNotFound
				} else if idx > 0 {
					c := components[l-1]
					components[l-1], verb = c[:idx], c[idx+1:]
				}
				if dataMap, err := pattern_{{ $service.Name }}_{{ $handler.Name }}_{{ $binding.Index }}.Match(components, verb); err == nil {
					if req.Method != "{{ $binding.HTTPMethod }}" {
						return req, "", nil, types.ErrMethodNotFound
					}
					data := &{{ $handler.In }}{}
					if req.Method == "GET" {
						for k, v := range dataMap {
							runtime.PopulateFieldFromPath(data, k, v)
						}
					} else {
						decoder := json.NewDecoder(req.Body)
						err := decoder.Decode(data)
						req.Body.Close()
						if err != nil {
							return req, "", nil, fmt.Errorf("Could not decode request: %s, ", err)
						}
					}
					return req.WithContext(_{{ $service.Name }}NewContext(req.Context(), &_{{ $service.Name }}CodecData{
						method: "{{ $handler.Name }}",
						request: data,
					})), "{{ $handler.Name }}", data, nil
				}
			{{ end }}
		{{ else }}
			if len(components) == 2 && components[0] == "{{ $service.Name }}" && components[1] == "{{ $handler.Name }}" {
				if req.Method != "POST" {
					return req, "", nil, types.ErrMethodNotFound
				}
				data := &{{ $handler.In }}{}
				decoder := json.NewDecoder(req.Body)
				err := decoder.Decode(data)
				req.Body.Close()
				if err == nil {
					return req.WithContext(_{{ $service.Name }}NewContext(req.Context(), &_{{ $service.Name }}CodecData{
						method: "{{ $handler.Name }}",
						request: data,
					})), "{{ $handler.Name }}", data, nil
				}
				return req, "", nil, fmt.Errorf("Could not decode request: %s, ", err)
			}
		{{ end }}
	{{ end }}
	return req, "", nil, types.ErrMethodNotFound
}

func (c *{{ $service.Name }}Codec) WriteResponse(w http.ResponseWriter, resp interface{}, err error) error {
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		bResp, _ := json.Marshal(&defaultError{Error: err.Error()})
		_, err = w.Write(bResp)
		return err
	}
	bResp, err := json.Marshal(resp)
	if err != nil {
		return err
	}
	_, err = w.Write(bResp)
	return err
}


type _{{ $service.Name }}CodecData struct {
	method string
	request interface{}
}

type _{{ $service.Name }}CtxKeyType int

var _{{ $service.Name }}CtxKey _{{ $service.Name }}CtxKeyType

func _{{ $service.Name }}NewContext(ctx context.Context, d *_{{ $service.Name }}CodecData) context.Context {
	return context.WithValue(ctx, _{{ $service.Name }}CtxKey, d)
}

func _{{ $service.Name }}FromContext(ctx context.Context) (*_{{ $service.Name }}CodecData, bool) {
	data := ctx.Value(_{{ $service.Name }}CtxKey)
	if data == nil {
		return nil, false
	}
	d, ok := data.(*_{{ $service.Name }}CodecData)
	return d, ok
}

{{ end }}

type defaultError struct {
	Error string ` + "`json:\"error\"`" + `
}

var (
	{{range $service := .Services}}
	{{range $handler := $service.Handlers}}
	{{range $binding := $handler.Bindings}}
	pattern_{{ $service.Name }}_{{ $handler.Name }}_{{ $binding.Index }} = runtime.MustPattern(runtime.NewPattern({{ $binding.PathTmpl.Version }}, {{ $binding.PathTmpl.OpCodes | printf "%#v" }}, {{ $binding.PathTmpl.Pool | printf "%#v" }}, {{ $binding.PathTmpl.Verb | printf "%q" }}))
	{{ end }}
	{{ end }}
	{{ end }}
)

`))}
